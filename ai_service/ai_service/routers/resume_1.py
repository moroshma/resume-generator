# routers/resume.py
import logging
import datetime
import traceback
from fastapi import APIRouter, Body, HTTPException, status, Response
from typing import List, Dict, Any
# Import the updated NeuralService (assuming filename is neural.py)
from ai_service.services.neural_1 import NeuralService
# Keep PDF imports if needed for the PDF endpoint
from ai_service.services.pdf_generator import create_resume_pdf
from pydantic import BaseModel, Field # Import BaseModel and Field for new schemas

# Import existing schemas (adjust paths/names if needed)
from ai_service.schemas.resume_1 import (
    UserAnswers,
    UpdateRequest,
    QuestionsResponse,
    LabelValueItem
    # Removed GeneratedSkillsResponse, UpdatedSkillsResponse as we'll redefine/rename below
)

from ai_service.config import settings

log = logging.getLogger(__name__)


class ResumeDataPdfRequest(BaseModel):
    """
    Схема запроса для генерации PDF на основе структурированных данных.
    """
    resume_data: List[LabelValueItem] = Field(..., description="Полные структурированные данные резюме (список label-value) для генерации PDF.")


# --- Define necessary Response Schemas ---

class GeneratedResumeDataResponse(BaseModel):
    """Schema for the structured data generated from all answers."""
    hard_skills: List[str] = Field(..., description="List of extracted hard skills.")
    experience_summary: str = Field(..., description="AI-generated summary of user's experience.")
    technologies: List[str] = Field(..., description="List of technologies mentioned.")

class UpdatedResumeSectionResponse(BaseModel):
    """Schema for the response when a resume section is updated."""
    updated_text: str = Field(..., description="The updated text for the resume section, generated by the AI.")


# --- Router Setup ---

router = APIRouter(tags=["Resume Generation API"]) # Updated tag

# Create an instance of the *updated* NeuralService
neural_service = NeuralService(settings)

# --- Endpoints ---

@router.get("/api/v001/resume/basic/question", response_model=QuestionsResponse)
async def get_base_questions():
    """
    Retrieves the initial list of base questions for the resume generation process (Stage 1).
    """
    # This endpoint reads static data from settings, no change needed here.
    return {"questions": settings.BASE_QUESTIONS}


# Use the actual NeuralService to generate follow-up questions
@router.post("/api/v001/resume/question/get", response_model=QuestionsResponse)
async def get_next_questions(user_answers: UserAnswers = Body(...)):
    """
    Generates follow-up questions (Stage 2) based on the user's answers from Stage 1.
    Requires authentication (JWT - implied, handle elsewhere).
    """
    if not user_answers.answers:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Answers cannot be empty when requesting follow-up questions.",
        )

    try:
        # Call the service method to generate questions using the Gemini API
        follow_up_questions = await neural_service.generate_follow_up_questions(user_answers.answers)
        # Return the generated questions in the correct format
        return {"questions": follow_up_questions}
    except Exception as e:
        # Log the error server-side for debugging.
        print(f"Error in /api/v001/resume/question/get endpoint: {e}")
        # Raise an HTTPException for server-side errors (5xx).
        # Avoid exposing detailed internal error messages to the client in production.
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            # Provide a user-friendly error message
            detail=f"Failed to generate follow-up questions. Error: {str(e)}",
            # Optionally include specific error type/details in development/debug mode
            # detail=f"Failed to generate follow-up questions. Error: {type(e).__name__}: {str(e)}"
        )


# Use the actual NeuralService to process all answers and generate resume data
@router.post("/api/v001/resume/label/generate", response_model=List[LabelValueItem])
async def generate_resume_final(user_answers: UserAnswers = Body(...)):
    """
    Processes all user answers to generate structured resume data as a list of label/value pairs.
    """
    if not user_answers.answers:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Answers cannot be empty for final resume generation.",
        )

    try:
        # neural_service.process_answers returns List[Dict[str, Any]]
        # FastAPI will validate if each item in the returned list matches LabelValueItem
        structured_data = await neural_service.process_answers(user_answers.answers)
        return structured_data
    except Exception as e:
        print(f"Error in /api/v001/resume/label/generate endpoint: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate resume data. Error: {str(e)}",
        )




# Use the actual NeuralService to update/regenerate a section
@router.post("/api/v001/resume/label/regenerate", response_model=List[LabelValueItem])
async def update_resume_section(update_req: UpdateRequest = Body(...)):
    """
    Updates resume data based on current structured data and new info,
    returning the complete, updated list of label/value pairs.
    """
    # Input validation based on the corrected UpdateRequest schema
    if not update_req.current_data and not update_req.new_info:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Either current_data or new_info must be provided for regeneration.",
         )
    # You might add more specific validation if needed (e.g., new_info cannot be empty if current_data is)

    try:
        # Pass the data matching the service method's signature
        # update_resume expects: current_data: List[Dict[str, Any]], new_info: str
        updated_structured_data = await neural_service.update_resume(
            # Pydantic automatically converts update_req.current_data (List[LabelValueItem])
            # to List[Dict] when passing it, which matches the expected type hint.
            current_data=update_req.current_data,
            new_info=update_req.new_info
        )
        # FastAPI validates the returned list against List[LabelValueItem]
        return updated_structured_data
    except Exception as e:
        print(f"Error in /api/v001/resume/label/regenerate endpoint: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to update resume section. Error: {str(e)}",
        )


# PDF Generation Endpoint - Assumes skills/data are generated beforehand and passed in request
@router.post("/api/v001/resume/pdf/generate")
async def generate_resume_pdf(request_data: ResumeDataPdfRequest = Body(...)):
    """
    Генерирует PDF резюме на основе предоставленных структурированных данных (label-value).

    Принимает:
        request_data (ResumeDataPdfRequest): Тело запроса, содержащее список `resume_data`.

    Возвращает:
        Response: PDF файл для скачивания.
    """
    # Проверяем, что список данных не пустой
    if not request_data.resume_data:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Resume data cannot be empty for PDF generation.",
        )

    try:
        # Преобразуем список Pydantic моделей в список словарей для pdf_generator
        # Используем model_dump() для Pydantic v2 или dict() для v1
        resume_data_list = [item.model_dump() if hasattr(item, 'model_dump') else item.dict() for item in request_data.resume_data]

        # Вызываем обновленную функцию генерации PDF
        pdf_bytes = create_resume_pdf(resume_data_list)

        # Проверка типа остается важной
        if not isinstance(pdf_bytes, bytes):
             # Логирование уже должно быть в create_resume_pdf или generate
             raise TypeError(f"create_resume_pdf returned unexpected type: {type(pdf_bytes)}")

        # Формируем ответ с PDF файлом
        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={
                # Можно добавить дату/время в имя файла
                "Content-Disposition": f"attachment; filename=resume_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            }
        )

    except HTTPException as http_exc:
        # Перехватываем ошибки валидации FastAPI
        raise http_exc
    except Exception as e:
        # Обрабатываем ошибки во время генерации PDF
        log.error(f"Error in /api/v001/resume/pdf/generate endpoint during PDF creation: {e}", exc_info=True)
        import traceback
        traceback.print_exc() # Печатаем traceback для отладки PDF ошибок
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate resume PDF. Internal error: {str(e)}",
        )
