# routers/resume.py

from fastapi import APIRouter, Body, HTTPException, status, Response
from typing import List, Dict, Any
# Import the updated NeuralService (assuming filename is neural.py)
from ai_service.services.neural_1 import NeuralService
# Keep PDF imports if needed for the PDF endpoint
from ai_service.services.pdf_generator import create_resume_pdf
from pydantic import BaseModel, Field # Import BaseModel and Field for new schemas

# Import existing schemas (adjust paths/names if needed)
from ai_service.schemas.resume_1 import (
    UserAnswers,
    UpdateRequest,
    QuestionsResponse,
    ResumePdfRequest,
    LabelValueItem
    # Removed GeneratedSkillsResponse, UpdatedSkillsResponse as we'll redefine/rename below
)

from ai_service.config import settings

# --- Define necessary Response Schemas ---

class GeneratedResumeDataResponse(BaseModel):
    """Schema for the structured data generated from all answers."""
    hard_skills: List[str] = Field(..., description="List of extracted hard skills.")
    experience_summary: str = Field(..., description="AI-generated summary of user's experience.")
    technologies: List[str] = Field(..., description="List of technologies mentioned.")

class UpdatedResumeSectionResponse(BaseModel):
    """Schema for the response when a resume section is updated."""
    updated_text: str = Field(..., description="The updated text for the resume section, generated by the AI.")


# --- Router Setup ---

router = APIRouter(tags=["Resume Generation API"]) # Updated tag

# Create an instance of the *updated* NeuralService
neural_service = NeuralService(settings)

# --- Endpoints ---

@router.get("/api/v001/resume/basic/question", response_model=QuestionsResponse)
async def get_base_questions():
    """
    Retrieves the initial list of base questions for the resume generation process (Stage 1).
    """
    # This endpoint reads static data from settings, no change needed here.
    return {"questions": settings.BASE_QUESTIONS}


# Use the actual NeuralService to generate follow-up questions
@router.post("/api/v001/resume/question/get", response_model=QuestionsResponse)
async def get_next_questions(user_answers: UserAnswers = Body(...)):
    """
    Generates follow-up questions (Stage 2) based on the user's answers from Stage 1.
    Requires authentication (JWT - implied, handle elsewhere).
    """
    if not user_answers.answers:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Answers cannot be empty when requesting follow-up questions.",
        )

    try:
        # Call the service method to generate questions using the Gemini API
        follow_up_questions = await neural_service.generate_follow_up_questions(user_answers.answers)
        # Return the generated questions in the correct format
        return {"questions": follow_up_questions}
    except Exception as e:
        # Log the error server-side for debugging.
        print(f"Error in /api/v001/resume/question/get endpoint: {e}")
        # Raise an HTTPException for server-side errors (5xx).
        # Avoid exposing detailed internal error messages to the client in production.
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            # Provide a user-friendly error message
            detail=f"Failed to generate follow-up questions. Error: {str(e)}",
            # Optionally include specific error type/details in development/debug mode
            # detail=f"Failed to generate follow-up questions. Error: {type(e).__name__}: {str(e)}"
        )


# Use the actual NeuralService to process all answers and generate resume data
@router.post("/api/v001/resume/label/generate", response_model=List[LabelValueItem])
async def generate_resume_final(user_answers: UserAnswers = Body(...)):
    """
    Processes all user answers to generate structured resume data as a list of label/value pairs.
    """
    if not user_answers.answers:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Answers cannot be empty for final resume generation.",
        )

    try:
        # neural_service.process_answers returns List[Dict[str, Any]]
        # FastAPI will validate if each item in the returned list matches LabelValueItem
        structured_data = await neural_service.process_answers(user_answers.answers)
        return structured_data
    except Exception as e:
        print(f"Error in /api/v001/resume/label/generate endpoint: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate resume data. Error: {str(e)}",
        )




# Use the actual NeuralService to update/regenerate a section
@router.post("/api/v001/resume/label/regenerate", response_model=List[LabelValueItem])
async def update_resume_section(update_req: UpdateRequest = Body(...)):
    """
    Updates resume data based on current structured data and new info,
    returning the complete, updated list of label/value pairs.
    """
    # Input validation based on the corrected UpdateRequest schema
    if not update_req.current_data and not update_req.new_info:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Either current_data or new_info must be provided for regeneration.",
         )
    # You might add more specific validation if needed (e.g., new_info cannot be empty if current_data is)

    try:
        # Pass the data matching the service method's signature
        # update_resume expects: current_data: List[Dict[str, Any]], new_info: str
        updated_structured_data = await neural_service.update_resume(
            # Pydantic automatically converts update_req.current_data (List[LabelValueItem])
            # to List[Dict] when passing it, which matches the expected type hint.
            current_data=update_req.current_data,
            new_info=update_req.new_info
        )
        # FastAPI validates the returned list against List[LabelValueItem]
        return updated_structured_data
    except Exception as e:
        print(f"Error in /api/v001/resume/label/regenerate endpoint: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to update resume section. Error: {str(e)}",
        )


# PDF Generation Endpoint - Assumes skills/data are generated beforehand and passed in request
@router.post("/api/v001/resume/pdf/generate")
async def generate_resume_pdf(request_data: ResumePdfRequest = Body(...)):
    """
    Generates a PDF resume summary based on provided answers and previously generated skills/data.
    Requires authentication (JWT - implied, handle elsewhere).

    Note: Expects `generated_skills` (in the format required by `create_resume_pdf`)
          to be included in the request body, typically obtained from a prior call
          to `/api/v001/resume/label/generate`.

    Returns:
        Response: A PDF file download.
    """
    if not request_data.answers:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Answers cannot be empty for PDF generation.",
        )
    # Add validation for generated_skills structure if needed by create_resume_pdf
    if not request_data.generated_skills:
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail="Generated skills/data must be provided for PDF generation.",
         )

    try:
        # Directly use the provided answers and generated skills for PDF creation
        pdf_bytes = create_resume_pdf(request_data.answers, request_data.generated_skills)

        # Ensure pdf_bytes is actually bytes (create_resume_pdf might return buffer/stream)
        if hasattr(pdf_bytes, 'read'): # Check if it's a file-like object
            pdf_content = pdf_bytes.read()
            if hasattr(pdf_bytes, 'close'):
                pdf_bytes.close()
        elif isinstance(pdf_bytes, bytes):
            pdf_content = pdf_bytes
        else:
            # Handle unexpected type from create_resume_pdf
            raise TypeError(f"create_resume_pdf returned unexpected type: {type(pdf_bytes)}")


        return Response(
            content=pdf_content,
            media_type="application/pdf",
            headers={
                "Content-Disposition": "attachment; filename=resume_summary.pdf"
            }
        )

    except HTTPException as http_exc:
        # Re-raise HTTPExceptions that might occur during input validation
        raise http_exc
    except Exception as e:
        # Handle potential errors during PDF creation.
        print(f"Error in /api/v001/resume/pdf/generate endpoint during PDF creation: {e}")
        import traceback
        traceback.print_exc() # Print full traceback for PDF errors
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to generate resume PDF. Please check PDF generation logic.",
        )
