import logging
import datetime
import traceback
from fastapi import APIRouter, Body, HTTPException, status, Response, Request
from typing import List, Dict, Any
from ai_service.services.neural_1 import NeuralService
from ai_service.services.pdf_generator import create_resume_pdf
from pydantic import BaseModel, Field
import httpx

from ai_service.schemas.resume_1 import (
    UserAnswers,
    UpdateRequest,
    QuestionsResponse,
    LabelValueItem
)

from ai_service.config import settings

log = logging.getLogger(__name__)


class ResumeDataPdfRequest(BaseModel):
    resume_data: List[LabelValueItem] = Field(..., description="Полные структурированные данные резюме (список label-value) для генерации PDF.")


class GeneratedResumeDataResponse(BaseModel):
    hard_skills: List[str] = Field(..., description="List of extracted hard skills.")
    experience_summary: str = Field(..., description="AI-generated summary of user's experience.")
    technologies: List[str] = Field(..., description="List of technologies mentioned.")

class UpdatedResumeSectionResponse(BaseModel):
    updated_text: str = Field(..., description="The updated text for the resume section, generated by the AI.")



async def _get_user_info(user_service_url: str, headers: Dict[str, str]) -> Dict[str, Any]:
    async with httpx.AsyncClient() as client:
        try:
            log.debug(f"Requesting user info from: {user_service_url}")
            response = await client.get(user_service_url, headers=headers)
            response.raise_for_status()
            user_data = response.json()
            log.debug(f"Successfully retrieved user info: {list(user_data.keys())}")
            return user_data
        except httpx.HTTPStatusError as exc:
            log.error(f"HTTP error occurred while requesting user info: {exc.response.status_code} - {exc.response.text}")
            if exc.response.status_code == 404:
                 raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User info not found.")
            raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=f"User service failed with status {exc.response.status_code}.")
        except httpx.RequestError as exc:
            log.error(f"Network error occurred while requesting user info: {exc}")
            raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=f"Could not connect to user service: {exc}")
        except Exception as e:
            log.error(f"An unexpected error occurred during user info retrieval: {e}", exc_info=True)
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to retrieve user info due to an internal error.")

router = APIRouter(tags=["Resume Generation API"])

neural_service = NeuralService(settings)

@router.get("/api/v001/resume/basic/question", response_model=QuestionsResponse)
async def get_base_questions():
    return {"questions": settings.BASE_QUESTIONS}

@router.post("/api/v001/resume/question/get", response_model=QuestionsResponse)
async def get_next_questions(user_answers: UserAnswers = Body(...)):
    """
    Generates follow-up questions (Stage 2) based on the user's answers from Stage 1.
    Requires authentication (JWT - implied, handle elsewhere).
    """
    if not user_answers.answers:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Answers cannot be empty when requesting follow-up questions.",
        )

    try:
        follow_up_questions = await neural_service.generate_follow_up_questions(user_answers.answers)
        return {"questions": follow_up_questions}
    except Exception as e:
        print(f"Error in /api/v001/resume/question/get endpoint: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate follow-up questions. Error: {str(e)}",
        )

@router.post("/api/v001/resume/label/generate", response_model=List[LabelValueItem])
async def generate_resume_final(user_answers: UserAnswers = Body(...)):
    """
    Processes all user answers to generate structured resume data as a list of label/value pairs.
    """
    if not user_answers.answers:
         raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Answers cannot be empty for final resume generation.",
        )

    try:
        structured_data = await neural_service.generate_structured_resume(user_answers.answers)
        return structured_data
    except Exception as e:
        print(f"Error in /api/v001/resume/label/generate endpoint: {e}")
        traceback.print_exc()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate structured resume. Error: {str(e)}",
        )

@router.post("/api/v001/resume/label/update", response_model=List[LabelValueItem])
async def update_resume_section(update_request: UpdateRequest = Body(...)):
    """
    Updates a specific section of the resume based on user's new input.
    """
    try:
        updated_data = await neural_service.update_structured_resume(
            current_data=update_request.current_data,
            user_input=update_request.user_input
        )
        return updated_data
    except Exception as e:
        log.error(f"Error updating resume section: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update resume section.",
        )

@router.post("/api/v001/resume/generate/pdf", status_code=status.HTTP_200_OK)
async def generate_resume_pdf(
    request: Request,
    pdf_request: ResumeDataPdfRequest = Body(...)
):
    """
    Generates a PDF resume from the final structured data and user information.
    Requires authentication.
    """
    try:
        headers = {
            "Cookie": request.headers.get("Cookie")
        }
        user_info = await _get_user_info(settings.USER_SERVICE_URL, headers)

        pdf_bytes = create_resume_pdf(
            resume_data=pdf_request.resume_data,
            user_info=user_info
        )

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"resume_{user_info.get('name', 'user')}_{timestamp}.pdf"

        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        log.error(f"Failed to generate PDF: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred while generating the PDF: {e}"
        )
